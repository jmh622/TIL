로버트 마틴(Robert Cecil Martin)이 제안한 `객체 지향 프로그래밍`의 다섯 가지 기본 원칙

# SOLID

- S
  - SRP (Single Responsibility Principle)
  - 단일 책임 원칙: 한 클래스는 하나의 책임만 가져야 한다.
- O
  - OCP (Open/Closed Principle)
  - 개방-폐쇄 원칙: 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- L
  - LSP (Liskov Substitution Principle)
  - 리스코프 치환 원칙: 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- I
  - ISP (Interface Segregation Principle)
  - 인터페이스 분리 원칙: 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- D
  - DIP (Dependency Inversion Principle)
  - 의존관계 역전 원칙: 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.

## SRP

한 클래스는 하나의 책임만 가져야 한다.

여기서 하나의 책임이라는 것이 조금 애매하다.

하나의 책임이 클 수도, 작을 수도 있다.

따라서 중요한 것은 하나의 클래스를 변경했을 때 파급효과가 적어야 하다는 것이다.

## OCP

소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

문장만 보면 뭔가 모순이 되는 말 같다.

다시 풀어서 얘기해보자면, 인터페이스를 이용하여 확장은 무한히 가능하도록 하고 인터페이스의 구현체가 바뀌더라도 해당 인터페이스를 참조하는 곳에서는 변경이 일어나지 않도록 한다는 것이다.

스프링 프레임워크로 웹 개발을 할 때 대부분이 사용하는 Repository로 예를 들어 보자.

Repository를 참조하는 곳(ex. 컨트롤러)에서는 Repository Interface만을 참조하도록 코드를 작성한다.

만약 컨트롤러에서 RepositoryImpl(Jdbc 이용)을 직접적으로 참조하고 있다면 OCP를 위반하는 것이다. 만약 Jdbc가 아니라 JpaRepository로 바꿔야 한다면 어떻게 될까? Repository가 바뀜에 따라 컨트롤러 역시 바뀌어야 하므로, 변경에 열려있게 되는 것이다.

스프링과 같은 DI 컨테이너를 이용한다면 OCP를 지킬 수 있게 된다.

## LSP

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

이는 코드와 직접적으로 관련되었다기 보다는 인터페이스가 정의한 내용들(규약)을 구현체에서는 정확하게 신뢰할 수 있게 지켜야 한다는 것이다.

## ISP

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

이는 사실 SRP와도 연관되어 있다고 볼 수 있다.

하나의 클래스에서 하나의 책임만 가져야 하듯이, 인터페이스 역시 하나의 인터페이스에 너무 많은 내용이 들어간 범용 인터페이스일 때보다 각 역할과 책임에 의해 여러 개의 인터페이스로 분리하는 것이 인터페이스가 명확해지고 대체 가능성이 높아지는 길이다.

## DIP

프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.

말 그대로 구현체에 의존하지 말고 인터페이스에 의존하라는 뜻이다.

OCP와 일맥상통한 이야기이기도 하다. 결국 추상화에 의존하게 되면 확장에는 열려 있고 변경에는 닫혀 있게 되는 것이다.

DIP 역시 DI 컨테이너를 이용한다면 지킬 수 있게 된다.

### References

- [위키백과](<https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)>)
- [인프런 - 스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)
